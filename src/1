#include "colorFace.h"
#include "loadOBJ.h"
#include "ReadSim.h"
#include <math.h>
#include <stdlib.h> 
#include <sstream> 
#include <fstream> 

using namespace qglviewer;
using namespace std;

///////////////////////   V i e w e r  ///////////////////////
void Viewer::init()
{
  restoreStateFromFile();
  glDisable(GL_LIGHTING);

  readData(); 
  Nts = data[0].pressure.size(); 
  NCell = data.size(); 

  source1max=0; 
  source2max=0; 
  for (int i=0; i<NCell; i++) 
  {
     for (int j=0; j<Nts; j++) 
     {
        //std::cout << "scanning through... " << i << " " << j << std::endl;
        double s1 = data[i].source1[j];
        double s2 = data[i].source2[j];
        if (abs(s1)>source1max) { source1max=abs(s1); } 
        if (abs(s2)>source2max) { source2max=abs(s2); } 
     }
  }


  data[0].printPressure();
  data[1].printPressure();


  //std::cout << NCell << " " << Nts << std::endl;
    
    
  particle_ = new Particle[NCell];
  //head_ = new Head;  
  
  //head_->Nts   = data[0].pressure.size();
  //head_->NCell = data.size();



  //std::cout << head_->NCell << std::endl;

  glPointSize(4.0);
  setGridIsDrawn(false);
  setAnimationPeriod(60000000);
//  help();

  startAnimation();
}

void Viewer::readData() 
{ 
   ReadSim(data); 
} 

void Viewer::draw()
{
  glBegin(GL_POINTS);

  for (int i=0; i<NCell; i++)
  {
     //std::cout << i << " " << std::endl;

     double ratio1 = data[i].source1[1000]/source1max;
     double ratio2 = data[i].source2[1000]/source2max;

     //double r = ratio1; 
     //double g = 0.0f; 
     //double b = ratio2; 

     glColor3f(ratio1, 0.0f , ratio2);
     Vec vertPos(data[i].positions.x,data[i].positions.y,data[i].positions.z); 
     glVertex3fv(vertPos);
  }
  glEnd();
}

void Viewer::animate()
{
  //for (int i=0; i<nbPart_; i++)
  //  particle_[i].animate();
}

QString Viewer::helpString() const
{
  QString text("<h2>A n i m a t i o n</h2>");
  text += "Use the <i>animate()</i> function to implement the animation part of your ";
  text += "application. Once the animation is started, <i>animate()</i> and <i>draw()</i> ";
  text += "are called in an infinite loop, at a frequency that can be fixed.<br><br>";
  text += "Press <b>Return</b> to start/stop the animation.";
  return text;
}

///////////////////////   P a r t i c l e   ///////////////////////////////

Particle::Particle()
{
  init();
}

void Particle::animate()
{
//  speed_.z -= 0.05f;
//  //pos_ += 0.1f * speed_;
//  pos_ = Vec(0.1f,0.1f,0.1f);
//
//  if (pos_.z < 0.0)
//    {
//      speed_.z = -0.8*speed_.z;
//      pos_.z = 0.0;
//    }

  //if (++age_ == ageMax_)
  //  init();
}

void Particle::draw()
{
  glColor3f(1, age_/(float)ageMax_, age_/(float)ageMax_);
  glVertex3fv(pos_);
}


void Particle::init()
{
  pos_ = Vec(0.0, 0.0, 0.0);
  float angle = 2.0 * M_PI * rand() / RAND_MAX;
  float norm  = 0.04 * rand() / RAND_MAX;
  speed_ = Vec(norm*cos(angle), norm*sin(angle), rand() / static_cast<float>(RAND_MAX) );
  age_ = 0;
  ageMax_ = 50 + static_cast<int>(100.0 * rand() / RAND_MAX);

}


///////////////////////// H e a d /////////////////////////////
//Head::Head()
//{
//   init(); 
//} 
//
//void Head::animate()
//{
//}
//
//void Head::draw()
//{
//   
